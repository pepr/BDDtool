#!python3
"""Catch code to feature definitions."""

import tsyn
import glob
import os
import textwrap

class FeatureGenerator:
    """Converts a syntax tree to the feature definition.

    Returns the list of text lines of the feature definition.
    """

    def __init__(self):
        """Default settings initialization.
        """

    def extract(self, syntax_tree):
        """Returns list of lines of the feature definition from a syntax_tree.
        """
        return ['extract method not implemented']


def catch_to_feature(fname_in, fname_out):
    """Converts the source of a Catch test to the feature definition.
    """
    # Open the input file with the Catch sourceand the output file with
    # *.feature file or the *.catch if the feature file already exist.
    with open(fname_in, encoding='utf_8') as fin, \
         open(fname_out, 'w', encoding='utf_8') as fout:

        # Get the syntax tree for the feature description.
        sa = tsyn.SyntacticAnalyzerForCatch(fin)
        tree = sa.Start()
        print(tree)

        # Generate the lines of the skeleton from the syntaxt tree.
        fg = FeatureGenerator()
        lst = fg.extract(tree)

        # Some reference to the tool.
        script_name = os.path.realpath(__file__)
        lst.append('')
        lst.append('// ----------------------------------------------------------')
        lst.append('// The skeleton was generated by ' + script_name + '.')
        lst.append('// Then the skeleton was updated manually.')
        lst.append('// See https://github.com/pepr/BDDtool.git')

        # Write the result to the output file.
        fout.write('\n'.join(lst))



if __name__ == '__main__':

    # Input directory with generated *.h or *.skeleton files.
    tests_dir = os.path.realpath('./tests')
    if not os.path.isdir(tests_dir):
        os.makedirs(tests_dir)

    # Output directory with *.feature definitions.
    features_dir = os.path.realpath('./features')
    if not os.path.isdir(features_dir):
        os.makedirs(features_dir)

    # build the list of input files with *.h and *.hpp extensions, delete
    # the catch.hpp.
    flst = [fname for fname in glob.glob(os.path.join(tests_dir, '*.hpp'))
                      if not fname.endswith('catch.hpp')]
    flst.extend(glob.glob(os.path.join(tests_dir, '*.h')))
    
    for fname_in in flst:
        path, bname = os.path.split(fname_in)
        name, ext = os.path.splitext(bname)

        # If the feature file does not exist, it will be generated.
        # Otherwise, the .catch extension is used.
        fname_out = os.path.join(features_dir, name + '.feature')
        if os.path.isfile(fname_out):
            fname_out = os.path.join(tests_dir, name + '.catch')

        # Generate the output file.
        print(fname_in)
        catch_to_feature(fname_in, fname_out)