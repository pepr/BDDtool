#!python3
"""Catch code to feature definitions."""

import tsyn
import glob
import os
import textwrap

class FeatureDescriptionGenerator:
    """Converts a syntax tree to the feature definition.

    Returns the list of text lines of the feature definition.
    """

    def __init__(self):
        """Default settings initialization.
        """

    def extract(self, syntax_tree):
        """Returns list of lines of the feature definition from a syntax_tree.
        """
        out = []
        for item in syntax_tree:
            sym = item[0]
            if sym == 'story':
                out.append('Story: ' + item[1])

            elif sym == 'feature':
                out.append('Feature: ' + item[1])

            elif sym == 'description':
                out.append('')
                out.append('\n'.join(item[1]))

            elif sym == 'test_case':
                out.append('')
                out.append('Test: ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'section':
                out.append('  Sec: ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'scenario':
                out.append('')
                out.append('Scenario: ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'given':
                out.append('  Given ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'and_given':
                out.append('  and ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'when':
                out.append('  When ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'and_when':
                out.append('  and ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'then':
                out.append('  Then ' + item[1])
                out.extend(self.extract(item[2]))

            elif sym == 'and_then':
                out.append('  and ' + item[1])
                out.extend(self.extract(item[2]))
            else:
                raise NotImplementedError('Symbol: ' + sym)
        return out


def catch_to_feature(fname_in, fname_out):
    """Converts the source of a Catch test to the feature definition.
    """
    # Open the input file with the Catch sourceand the output file with
    # *.feature file or the *.catch if the feature file already exist.
    with open(fname_in, encoding='utf_8') as fin, \
         open(fname_out, 'w', encoding='utf_8') as fout:

        # Get the syntax tree for the feature description.
        sa = tsyn.SyntacticAnalyzerForCatch(fin)
        tree = sa.Start()

        ##???
        with open('syn.bak', 'w', encoding='utf-8') as f:
            f.write(repr(tree))

        # Generate the lines of the skeleton from the syntaxt tree.
        fg = FeatureDescriptionGenerator()
        lst = fg.extract(tree)

        # Some reference to the tool.
        script_name = os.path.realpath(__file__)
        lst.append('')
        lst.append('----------------------------------------------------------')
        lst.append('This file was generated by ' + script_name)
        lst.append('from ' + fname_in + ' source.')
        if fname_in.endswith('.catch'):
            lst.append('It was given the .catch extension because the related')
            lst.append('.feature file already exists. You can diff them.')
        lst.append(('Remove this comment section when you'
                    'want to convert it to the Catch test source.'))
        lst.append('See https://github.com/pepr/BDDtool.git')

        # Write the result to the output file.
        fout.write('\n'.join(lst))



if __name__ == '__main__':

    # Input directory with generated *.h or *.skeleton files.
    tests_dir = os.path.realpath('./tests')
    if not os.path.isdir(tests_dir):
        os.makedirs(tests_dir)

    # Output directory with *.feature definitions.
    features_dir = os.path.realpath('./features')
    if not os.path.isdir(features_dir):
        os.makedirs(features_dir)

    # build the list of input files with *.h and *.hpp extensions, delete
    # the catch.hpp.
    flst = [fname for fname in glob.glob(os.path.join(tests_dir, '*.hpp'))
                      if not fname.endswith('catch.hpp')]
    flst.extend(glob.glob(os.path.join(tests_dir, '*.h')))

    for fname_in in flst:
        path, bname = os.path.split(fname_in)
        name, ext = os.path.splitext(bname)

        # If the feature file does not exist, it will be generated.
        # Otherwise, the .catch extension is used.
        fname_out = os.path.join(features_dir, name + '.feature')
        if os.path.isfile(fname_out):
            fname_out = os.path.join(features_dir, name + '.catch')

        # Generate the output file.
        path, name = os.path.split(fname_in)
        path, subdir = os.path.split(path)
        src = os.path.join(subdir, name)

        path, name = os.path.split(fname_out)
        path, subdir = os.path.split(path)
        dest = os.path.join(subdir, name)

        print(src, '-->', dest)

        catch_to_feature(fname_in, fname_out)